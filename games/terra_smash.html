<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Terra Smash: Advanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            border-radius: 12px;
            overflow: hidden;
            cursor: none;
        }

        canvas {
            background: linear-gradient(to bottom, #ecf0f1, #bdc3c7);
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }

        .stat-box { text-align: left; }
        .stat-box.right { text-align: right; }

        .label {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #7f8c8d;
        }

        .value {
            font-size: 28px;
            font-weight: 700;
            margin: 0;
        }

        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #overlay-screen.active {
            opacity: 1;
            pointer-events: all;
            cursor: default;
        }

        h1 { font-size: 40px; margin-bottom: 10px; color: #2c3e50; }
        p { color: #7f8c8d; margin-bottom: 30px; }
        
        button {
            padding: 12px 30px;
            font-family: 'Montserrat', sans-serif;
            font-weight: bold;
            font-size: 16px;
            color: white;
            background-color: #e67e22;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(230, 126, 34, 0.5); }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="stat-box">
            <div class="label">Score</div>
            <div id="score" class="value">0</div>
        </div>
        <div class="stat-box right">
            <div class="label">Level</div>
            <div id="level" class="value">1</div>
        </div>
    </div>

    <div id="overlay-screen">
        <h1 id="end-title">GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restartBtn">TRY AGAIN</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const finalScoreEl = document.getElementById('final-score');
    const overlayScreen = document.getElementById('overlay-screen');
    const endTitle = document.getElementById('end-title');

    // --- Configuration ---
    const COLORS = {
        paddle: '#2c3e50',
        ball: '#e74c3c',
        bullet: '#e74c3c',
        bricks: ['#e67e22', '#f1c40f', '#1abc9c', '#3498db', '#9b59b6'],
        // Powerups
        pwMulti: '#1abc9c',  // Teal
        pwWide: '#f1c40f',   // Gold
        pwShoot: '#e74c3c',  // Red
        pwGlue: '#2ecc71'    // Green
    };

    // --- State ---
    let gameState = 'IDLE'; // IDLE, PLAYING, GAMEOVER, LEVEL_TRANSITION
    let score = 0;
    let currentLevel = 1;
    let mouseControl = true; // Switches if keys are used

    // Keys
    let rightPressed = false;
    let leftPressed = false;
    let spacePressed = false;

    // --- Game Objects ---
    let paddle = {
        width: 100,
        height: 16,
        x: 0,
        y: 0,
        baseWidth: 100,
        speed: 9,
        // Powerup States
        sticky: false,
        shooting: false,
        shootTimer: 0
    };

    let balls = [];
    let bricks = [];
    let particles = [];
    let powerUps = [];
    let bullets = [];

    // --- Graphics Helper ---
    function drawRoundedRect(x, y, w, h, r, color) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

    // --- Initialization ---
    function initGame() {
        score = 0;
        currentLevel = 1;
        scoreEl.innerText = score;
        levelEl.innerText = currentLevel;
        overlayScreen.classList.remove('active');
        loadLevel(currentLevel);
    }

    function loadLevel(lvl) {
        // Reset Paddle Powerups
        paddle.width = paddle.baseWidth;
        paddle.sticky = false;
        paddle.shooting = false;
        
        paddle.x = canvas.width / 2 - paddle.width / 2;
        paddle.y = canvas.height - 40;
        
        // Reset Ball
        balls = [{
            x: canvas.width / 2,
            y: canvas.height - 56, 
            dx: 0, 
            dy: 0,
            radius: 8,
            speed: 6 + (lvl * 0.5), // Faster every level
            active: true,
            isStuck: true,
            stuckOffset: 0
        }];

        particles = [];
        powerUps = [];
        bullets = [];
        
        createBricks(lvl);
        gameState = 'IDLE';
    }

    // --- Level Generator ---
    function createBricks(lvl) {
        bricks = [];
        const rows = 6;
        const cols = 9;
        const padding = 15;
        const offsetTop = 80;
        const offsetLeft = 55;
        const brickWidth = 65;
        const brickHeight = 25;

        for(let c=0; c<cols; c++) {
            for(let r=0; r<rows; r++) {
                let shouldCreate = true;

                // Level Patterns
                if (lvl === 2) { // Checkerboard
                    if ((c + r) % 2 === 0) shouldCreate = false;
                }
                else if (lvl === 3) { // Pyramid
                     // Simple logic to create a rough pyramid shape
                     let distFromCenter = Math.abs(c - 4);
                     if (r < distFromCenter) shouldCreate = false;
                }
                else if (lvl >= 4) { // Random gaps
                     if (Math.random() > 0.7) shouldCreate = false;
                }

                if (shouldCreate) {
                    let brickX = (c * (brickWidth + padding)) + offsetLeft;
                    let brickY = (r * (brickHeight + padding)) + offsetTop;
                    bricks.push({
                        x: brickX, 
                        y: brickY, 
                        w: brickWidth, 
                        h: brickHeight, 
                        status: 1, 
                        color: COLORS.bricks[r % COLORS.bricks.length]
                    });
                }
            }
        }
    }

    // --- Inputs ---
    document.addEventListener("keydown", (e) => {
        if(e.key === "Right" || e.key === "ArrowRight" || e.key === "d") {
            rightPressed = true;
            mouseControl = false;
        }
        else if(e.key === "Left" || e.key === "ArrowLeft" || e.key === "a") {
            leftPressed = true;
            mouseControl = false;
        }
        else if(e.key === " " || e.code === "Space") {
            if (!spacePressed) actionTrigger();
            spacePressed = true;
        }
    });

    document.addEventListener("keyup", (e) => {
        if(e.key === "Right" || e.key === "ArrowRight" || e.key === "d") rightPressed = false;
        else if(e.key === "Left" || e.key === "ArrowLeft" || e.key === "a") leftPressed = false;
        else if(e.key === " " || e.code === "Space") spacePressed = false;
    });

    document.addEventListener("mousemove", (e) => {
        if (gameState === 'GAMEOVER') return;
        mouseControl = true;
        const relativeX = e.clientX - canvas.getBoundingClientRect().left;
        if(relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
            clampPaddle();
        }
    }, false);

    document.addEventListener("mousedown", actionTrigger, false);

    function clampPaddle() {
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
    }

    function actionTrigger() {
        if (gameState === 'GAMEOVER') return;

        // 1. Launch from IDLE
        if (gameState === 'IDLE') {
            gameState = 'PLAYING';
            balls[0].isStuck = false;
            balls[0].dx = 4 * (Math.random() > 0.5 ? 1 : -1);
            balls[0].dy = -balls[0].speed;
            return;
        }

        // 2. Launch Stuck Balls (Sticky Powerup)
        if (gameState === 'PLAYING') {
            let releasedSomething = false;
            balls.forEach(b => {
                if (b.active && b.isStuck) {
                    b.isStuck = false;
                    // Calculate angle based on offset
                    let normOffset = b.stuckOffset / (paddle.width/2); // -1 to 1
                    let angle = normOffset * (Math.PI/3); // +/- 60 deg
                    b.dx = b.speed * Math.sin(angle);
                    b.dy = -b.speed * Math.cos(angle);
                    releasedSomething = true;
                }
            });

            // 3. Fire Gun (Shooting Powerup)
            if (!releasedSomething && paddle.shooting) {
                fireBullets();
            }
        }
    }

    function fireBullets() {
        // Spawn 2 bullets at edges of paddle
        bullets.push({ x: paddle.x + 5, y: paddle.y, w: 4, h: 10, dy: -10, active: true });
        bullets.push({ x: paddle.x + paddle.width - 9, y: paddle.y, w: 4, h: 10, dy: -10, active: true });
    }

    // --- Logic ---
    function spawnParticles(x, y, color) {
        for (let i = 0; i < 6; i++) {
            particles.push({
                x: x, y: y,
                dx: (Math.random() - 0.5) * 5,
                dy: (Math.random() - 0.5) * 5,
                life: 1.0, color: color, size: Math.random() * 3 + 2
            });
        }
    }

    function spawnPowerUp(x, y) {
        const rand = Math.random(); 
        // 12% Total Drop Rate
        
        let type = null;
        let color = null;
        let label = '';

        // Rarity Logic
        if (rand < 0.01) { // 1% - Rare
            type = 'wide'; color = COLORS.pwWide; label = 'W';
        } else if (rand < 0.04) { // 3%
            type = 'shoot'; color = COLORS.pwShoot; label = 'S';
        } else if (rand < 0.07) { // 3%
            type = 'sticky'; color = COLORS.pwGlue; label = 'G';
        } else if (rand < 0.12) { // 5%
            type = 'multi'; color = COLORS.pwMulti; label = 'M';
        }

        if (type) {
            powerUps.push({ x: x, y: y, type: type, dy: 3, color: color, label: label });
        }
    }

    function activatePowerUp(p) {
        if (p.type === 'wide') {
            paddle.width = paddle.baseWidth * 1.5;
            setTimeout(() => { paddle.width = paddle.baseWidth; }, 10000);
        } 
        else if (p.type === 'multi') {
            const refBall = balls.find(b => b.active) || balls[0];
            balls.push({
                x: refBall.x, y: refBall.y,
                dx: -refBall.dx, dy: refBall.dy,
                radius: refBall.radius, speed: refBall.speed, active: true, isStuck: false
            });
        }
        else if (p.type === 'sticky') {
            paddle.sticky = true;
            setTimeout(() => { paddle.sticky = false; }, 12000);
        }
        else if (p.type === 'shoot') {
            paddle.shooting = true;
            setTimeout(() => { paddle.shooting = false; }, 8000);
        }
    }

    function update() {
        if (gameState !== 'PLAYING' && gameState !== 'IDLE') return;

        // 0. Paddle Movement (Keys)
        if (!mouseControl) {
            if(rightPressed) paddle.x += paddle.speed;
            if(leftPressed) paddle.x -= paddle.speed;
            clampPaddle();
        }

        // IDLE State: Ball tracks paddle
        if (gameState === 'IDLE') {
            balls[0].x = paddle.x + paddle.width / 2;
            return; 
        }

        // 1. Powerups
        for (let i = powerUps.length - 1; i >= 0; i--) {
            let p = powerUps[i];
            p.y += p.dy;
            if (p.y + 15 >= paddle.y && p.y <= paddle.y + paddle.height &&
                p.x >= paddle.x && p.x <= paddle.x + paddle.width) {
                activatePowerUp(p);
                powerUps.splice(i, 1);
                continue;
            }
            if (p.y > canvas.height) powerUps.splice(i, 1);
        }

        // 2. Bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.y += b.dy;
            // Hit Brick?
            let hit = false;
            for(let brick of bricks) {
                if(brick.status === 1) {
                    if(b.x > brick.x && b.x < brick.x + brick.w && b.y > brick.y && b.y < brick.y + brick.h) {
                        brick.status = 0;
                        score += 10;
                        scoreEl.innerText = score;
                        spawnParticles(brick.x + brick.w/2, brick.y + brick.h/2, brick.color);
                        spawnPowerUp(brick.x + brick.w/2, brick.y + brick.h/2);
                        hit = true;
                        break;
                    }
                }
            }
            if (hit || b.y < 0) bullets.splice(i, 1);
        }

        // 3. Balls
        let activeBallsCount = 0;
        balls.forEach(ball => {
            if (!ball.active) return;
            activeBallsCount++;

            if (ball.isStuck) {
                // Keep ball relative to paddle
                ball.x = paddle.x + ball.stuckOffset;
                // Clamp stuck ball to paddle width if paddle shrinks
                if (ball.x < paddle.x) ball.x = paddle.x;
                if (ball.x > paddle.x + paddle.width) ball.x = paddle.x + paddle.width;
                return; // Skip physics
            }

            ball.x += ball.dx;
            ball.y += ball.dy;

            // Walls
            if(ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx = -ball.dx;
            if(ball.y - ball.radius < 0) ball.dy = -ball.dy;
            else if(ball.y - ball.radius > canvas.height) ball.active = false;

            // Paddle Collision
            if(ball.y + ball.radius > paddle.y && 
               ball.y - ball.radius < paddle.y + paddle.height &&
               ball.x > paddle.x && 
               ball.x < paddle.x + paddle.width) {
                
               if (ball.dy > 0) {
                   if (paddle.sticky) {
                       ball.isStuck = true;
                       ball.stuckOffset = ball.x - paddle.x;
                       ball.dy = 0;
                       ball.dx = 0;
                       ball.y = paddle.y - ball.radius; // sit on top
                   } else {
                       // Normal Bounce
                       let collidePoint = ball.x - (paddle.x + paddle.width/2);
                       collidePoint = collidePoint / (paddle.width/2);
                       let angle = collidePoint * (Math.PI/3);
                       
                       ball.dx = ball.speed * Math.sin(angle);
                       ball.dy = -ball.speed * Math.cos(angle);
                       ball.speed = Math.min(ball.speed * 1.02, 14); 
                   }
               }
            }

            // Bricks
            for(let b of bricks) {
                if(b.status === 1) {
                    if(ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                        ball.dy = -ball.dy;
                        b.status = 0;
                        score += 10;
                        scoreEl.innerText = score;
                        spawnParticles(b.x + b.w/2, b.y + b.h/2, b.color);
                        spawnPowerUp(b.x + b.w/2, b.y + b.h/2);
                        break; 
                    }
                }
            }
        });

        // 4. Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.dx;
            p.y += p.dy;
            p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        }

        // 5. Check Win/Loss
        if (activeBallsCount === 0) triggerGameOver(false);
        
        if (bricks.every(b => b.status === 0)) {
            currentLevel++;
            levelEl.innerText = currentLevel;
            loadLevel(currentLevel);
        }
    }

    function triggerGameOver(win) {
        gameState = 'GAMEOVER';
        endTitle.innerText = win ? "VICTORY" : "GAME OVER";
        finalScoreEl.innerText = score;
        overlayScreen.classList.add('active');
        document.body.style.cursor = 'default';
    }

    // --- Rendering ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Shadows
        ctx.shadowColor = 'rgba(0,0,0,0.1)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetY = 3;
        
        bricks.forEach(b => {
            if(b.status === 1) drawRoundedRect(b.x, b.y, b.w, b.h, 4, b.color);
        });

        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;

        // Draw Paddle (Change color if glue/shoot active)
        let paddleColor = COLORS.paddle;
        if (paddle.sticky) paddleColor = COLORS.pwGlue;
        if (paddle.shooting) paddleColor = COLORS.pwShoot;

        drawRoundedRect(paddle.x, paddle.y, paddle.width, paddle.height, 8, paddleColor);

        // Draw Balls
        balls.forEach(ball => {
            if (!ball.active) return;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
            ctx.fillStyle = COLORS.ball;
            ctx.fill();
            ctx.closePath();
        });

        // Draw Bullets
        ctx.fillStyle = COLORS.bullet;
        bullets.forEach(b => {
            ctx.fillRect(b.x, b.y, b.w, b.h);
        });

        // Draw PowerUps
        powerUps.forEach(p => {
            drawRoundedRect(p.x - 10, p.y - 10, 20, 20, 5, p.color);
            ctx.fillStyle = "white";
            ctx.font = "bold 12px Montserrat";
            ctx.textAlign = "center";
            ctx.fillText(p.label, p.x, p.y + 4);
        });

        // Draw Particles
        particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });

        // "Press Space" Hint
        if (gameState === 'IDLE' || (paddle.sticky && balls.some(b=>b.isStuck))) {
            ctx.fillStyle = "rgba(44, 62, 80, 0.5)";
            ctx.font = "bold 16px Montserrat";
            ctx.textAlign = "center";
            let msg = gameState === 'IDLE' ? "CLICK OR SPACE TO LAUNCH" : "CLICK TO RELEASE";
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2 + 100);
        }
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Start
    initGame();
    gameLoop();

    document.getElementById('restartBtn').addEventListener('click', initGame);

</script>
</body>
</html>