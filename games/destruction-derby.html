<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Destruction Derby - 2 Player</title>
<style>
body { 
    margin: 0; 
    overflow: hidden; 
    background: #2a2a2a; 
    font-family: 'Arial Black', sans-serif; 
}
canvas { 
    display: block; 
    background: #4a4a4a;
    box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
}
#ui { 
    position: absolute; 
    top: 10px; 
    left: 10px; 
    color: white; 
    pointer-events: none;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}
.health-bar {
    width: 200px;
    height: 30px;
    background: #333;
    border: 3px solid #fff;
    margin: 5px 0;
    position: relative;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
.health-fill {
    height: 100%;
    transition: width 0.3s;
    box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
}
.player1-health { background: linear-gradient(90deg, #ff0000, #ff6666); }
.player2-health { background: linear-gradient(90deg, #0066ff, #66aaff); }
.controls {
    font-size: 12px;
    margin-top: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 5px;
}
#gameover {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    padding: 40px;
    border-radius: 20px;
    color: white;
    text-align: center;
    display: none;
    border: 5px solid #ffd700;
}
#gameover h1 {
    font-size: 48px;
    margin: 0 0 20px 0;
    color: #ffd700;
    text-shadow: 0 0 20px #ffd700;
}
#gameover button {
    background: #ff0000;
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 20px;
    border-radius: 10px;
    cursor: pointer;
    margin-top: 20px;
    font-family: 'Arial Black', sans-serif;
}
#gameover button:hover {
    background: #cc0000;
    transform: scale(1.1);
}
</style>
</head>
<body>
<div id="ui">
    <div style="background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;">
        <h3 style="margin: 0 0 10px 0; color: #ff0000;">ðŸš— PLAYER 1 (RED)</h3>
        <div class="health-bar">
            <div id="health1" class="health-fill player1-health" style="width: 100%;"></div>
        </div>
        <p style="margin: 5px 0;">Shield: <span id="shield1">0</span>s</p>
        
        <h3 style="margin: 20px 0 10px 0; color: #0066ff;">ðŸš™ PLAYER 2 (BLUE)</h3>
        <div class="health-bar">
            <div id="health2" class="health-fill player2-health" style="width: 100%;"></div>
        </div>
        <p style="margin: 5px 0;">Shield: <span id="shield2">0</span>s</p>
        
        <div class="controls">
            <strong>Player 1:</strong> WASD<br>
            <strong>Player 2:</strong> Arrow Keys
        </div>
    </div>
</div>

<div id="gameover">
    <h1 id="winner">PLAYER 1 WINS!</h1>
    <p style="font-size: 24px;">Destruction Derby Champion!</p>
    <button onclick="location.reload()">PLAY AGAIN</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Game state
let gameOver = false;
let powerUps = [];
let particles = [];

// Car class
class Car {
    constructor(x, y, color, controls) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 80;
        this.angle = 0;
        this.speed = 0;
        this.acceleration = 0.25;
        this.friction = 0.06;
        this.maxSpeed = 8;
        this.rotationSpeed = 0.045;
        this.color = color;
        this.controls = controls;
        this.health = 100;
        this.maxHealth = 100;
        this.shield = 0;
        this.isDead = false;
        this.smokeTimer = 0;
        this.collidingWithWall = false;
        this.collidingWithCar = false;
        this.lastCollisionSpeed = 0;
    }
    
    update(keys, otherCar) {
        if (this.isDead) return;
        
        // Movement
        if (keys[this.controls.up]) this.speed += this.acceleration;
        if (keys[this.controls.down]) this.speed -= this.acceleration;
        
        // Friction
        if (this.speed > 0) this.speed -= this.friction;
        if (this.speed < 0) this.speed += this.friction;
        if (Math.abs(this.speed) < this.friction) this.speed = 0;
        
        // Speed limits
        if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
        if (this.speed < -this.maxSpeed / 2) this.speed = -this.maxSpeed / 2;
        
        // Rotation (only when moving)
        if (this.speed !== 0) {
            const flip = this.speed > 0 ? 1 : -1;
            if (keys[this.controls.left]) this.angle -= this.rotationSpeed * flip;
            if (keys[this.controls.right]) this.angle += this.rotationSpeed * flip;
        }
        
        // Position update
        this.x += Math.sin(this.angle) * this.speed;
        this.y -= Math.cos(this.angle) * this.speed;
        
        // Wall collision
        this.handleWallCollision();
        
        // Car collision
        this.handleCarCollision(otherCar);
        
        // Shield countdown
        if (this.shield > 0) this.shield -= 1/60;
        if (this.shield < 0) this.shield = 0;
        
        // Smoke effect when damaged
        if (this.health < 50 && this.speed !== 0) {
            this.smokeTimer++;
            if (this.smokeTimer > 5) {
                this.createSmoke();
                this.smokeTimer = 0;
            }
        }
    }
    
    handleWallCollision() {
        const margin = 30;
        let hitWall = false;
        let damage = 0;
        
        if (this.x < margin) {
            this.x = margin;
            hitWall = true;
            if (!this.collidingWithWall && Math.abs(this.speed) > 1) {
                damage = Math.abs(this.speed) * 3;
            }
            this.speed *= -0.5;
        }
        if (this.x > canvas.width - margin) {
            this.x = canvas.width - margin;
            hitWall = true;
            if (!this.collidingWithWall && Math.abs(this.speed) > 1) {
                damage = Math.abs(this.speed) * 3;
            }
            this.speed *= -0.5;
        }
        if (this.y < margin) {
            this.y = margin;
            hitWall = true;
            if (!this.collidingWithWall && Math.abs(this.speed) > 1) {
                damage = Math.abs(this.speed) * 3;
            }
            this.speed *= -0.5;
        }
        if (this.y > canvas.height - margin) {
            this.y = canvas.height - margin;
            hitWall = true;
            if (!this.collidingWithWall && Math.abs(this.speed) > 1) {
                damage = Math.abs(this.speed) * 3;
            }
            this.speed *= -0.5;
        }
        
        if (hitWall && !this.collidingWithWall && damage > 0) {
            this.takeDamage(damage);
            this.createImpactParticles(5);
        }
        
        this.collidingWithWall = hitWall;
    }
    
    handleCarCollision(otherCar) {
        if (otherCar.isDead) return;
        
        const dx = this.x - otherCar.x;
        const dy = this.y - otherCar.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = 60;
        
        if (distance < minDistance) {
            // Calculate collision angle
            const collisionAngle = Math.atan2(dy, dx);
            
            // Separate cars
            const overlap = minDistance - distance;
            this.x += Math.cos(collisionAngle) * overlap / 2;
            this.y += Math.sin(collisionAngle) * overlap / 2;
            otherCar.x -= Math.cos(collisionAngle) * overlap / 2;
            otherCar.y -= Math.sin(collisionAngle) * overlap / 2;
            
            // Only apply damage on INITIAL impact with sufficient speed
            const relativeSpeed = Math.abs(this.speed) + Math.abs(otherCar.speed);
            const minImpactSpeed = 2; // Minimum speed threshold for damage
            
            if (!this.collidingWithCar && relativeSpeed > minImpactSpeed) {
                // Check if hit from side (more damage)
                const thisAngleDiff = Math.abs(this.angle - collisionAngle);
                const otherAngleDiff = Math.abs(otherCar.angle - collisionAngle);
                
                const thisSideDamage = Math.sin(thisAngleDiff) * 1.5; // Side hits do more damage
                const otherSideDamage = Math.sin(otherAngleDiff) * 1.5;
                
                const baseDamage = relativeSpeed * 2;
                const thisDamage = baseDamage * (1 + thisSideDamage);
                const otherDamage = baseDamage * (1 + otherSideDamage);
                
                this.takeDamage(thisDamage);
                otherCar.takeDamage(otherDamage);
                
                // Create impact particles only on initial hit
                this.createImpactParticles(15, (this.x + otherCar.x) / 2, (this.y + otherCar.y) / 2);
                
                // Bounce effect - only on initial impact
                const bounceForce = 0.7;
                this.speed = this.speed * -bounceForce + Math.cos(collisionAngle) * relativeSpeed * 0.3;
                otherCar.speed = otherCar.speed * -bounceForce - Math.cos(collisionAngle) * relativeSpeed * 0.3;
            } else if (this.collidingWithCar) {
                // During continuous contact, just slow down gradually without bounce
                this.speed *= 0.95;
                otherCar.speed *= 0.95;
            }
            
            this.collidingWithCar = true;
        } else {
            this.collidingWithCar = false;
        }
    }
    
    takeDamage(amount) {
        if (this.shield > 0) {
            amount *= 0.1; // Shield reduces damage by 90%
        }
        
        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0;
            this.die();
        }
    }
    
    heal(amount) {
        this.health += amount;
        if (this.health > this.maxHealth) this.health = this.maxHealth;
    }
    
    activateShield(duration) {
        this.shield = duration;
    }
    
    die() {
        this.isDead = true;
        this.createExplosion();
        gameOver = true;
    }
    
    createSmoke() {
        const smokeX = this.x - Math.sin(this.angle) * 30;
        const smokeY = this.y + Math.cos(this.angle) * 30;
        
        for (let i = 0; i < 3; i++) {
            particles.push({
                x: smokeX + (Math.random() - 0.5) * 20,
                y: smokeY + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 60,
                maxLife: 60,
                size: Math.random() * 15 + 10,
                type: 'smoke'
            });
        }
    }
    
    createImpactParticles(count, x = this.x, y = this.y) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 30,
                maxLife: 30,
                size: Math.random() * 5 + 3,
                type: 'spark'
            });
        }
    }
    
    createExplosion() {
        for (let i = 0; i < 50; i++) {
            particles.push({
                x: this.x,
                y: this.y,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15,
                life: 60,
                maxLife: 60,
                size: Math.random() * 10 + 5,
                type: 'explosion'
            });
        }
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Shield effect
        if (this.shield > 0) {
            ctx.strokeStyle = `rgba(0, 255, 255, ${this.shield / 5})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(-this.width/2 + 5, -this.height/2 + 5, this.width, this.height);
        
        // Car body color varies with damage
        const damageRatio = this.health / this.maxHealth;
        let bodyColor = this.color;
        
        if (damageRatio < 0.5) {
            // Add some darkness/burn marks when damaged
            ctx.fillStyle = "#222";
            ctx.fillRect(-this.width/2 - 2, -this.height/2 - 2, this.width + 4, this.height + 4);
        }
        
        // Main body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        // Damage cracks
        if (damageRatio < 0.7) {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -20);
            ctx.lineTo(10, -10);
            ctx.moveTo(5, 0);
            ctx.lineTo(-5, 15);
            ctx.stroke();
        }
        
        // Windshield
        ctx.fillStyle = damageRatio > 0.5 ? "#4a90e2" : "#333";
        ctx.fillRect(-this.width/2 + 5, -this.height/2 + 10, this.width - 10, 15);
        
        // Headlights
        ctx.fillStyle = "#ffffaa";
        ctx.fillRect(-this.width/2 + 5, -this.height/2, 10, 5);
        ctx.fillRect(this.width/2 - 15, -this.height/2, 10, 5);
        
        // Taillights
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(-this.width/2 + 5, this.height/2 - 5, 10, 5);
        ctx.fillRect(this.width/2 - 15, this.height/2 - 5, 10, 5);
        
        ctx.restore();
    }
}

// Power-up class
class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'health' or 'shield'
        this.size = 25;
        this.rotation = 0;
        this.pulseTimer = 0;
    }
    
    update() {
        this.rotation += 0.05;
        this.pulseTimer += 0.1;
    }
    
    draw() {
        const pulse = Math.sin(this.pulseTimer) * 5;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        if (this.type === 'health') {
            // Health pack - green cross
            ctx.fillStyle = "#00ff00";
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00ff00";
            
            // Cross
            ctx.fillRect(-8, -(this.size + pulse)/2, 16, this.size + pulse);
            ctx.fillRect(-(this.size + pulse)/2, -8, this.size + pulse, 16);
        } else {
            // Shield - blue hexagon
            ctx.fillStyle = "#00ccff";
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00ccff";
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = Math.cos(angle) * (this.size + pulse);
                const y = Math.sin(angle) * (this.size + pulse);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    checkCollision(car) {
        const dx = this.x - car.x;
        const dy = this.y - car.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.size + 30) {
            if (this.type === 'health') {
                car.heal(30);
            } else {
                car.activateShield(5);
            }
            return true;
        }
        return false;
    }
}

// Initialize cars
const player1 = new Car(
    canvas.width * 0.3, 
    canvas.height / 2, 
    "#ff0000",
    { up: 'w', down: 's', left: 'a', right: 'd' }
);

const player2 = new Car(
    canvas.width * 0.7, 
    canvas.height / 2, 
    "#0066ff",
    { up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright' }
);

player2.angle = Math.PI; // Face opposite direction

// Input handling
const keys = {};
window.addEventListener("keydown", (e) => {
    keys[e.key.toLowerCase()] = true;
});
window.addEventListener("keyup", (e) => {
    keys[e.key.toLowerCase()] = false;
});

// Spawn power-ups
function spawnPowerUp() {
    if (powerUps.length < 3 && Math.random() < 0.02) {
        const type = Math.random() < 0.5 ? 'health' : 'shield';
        const x = Math.random() * (canvas.width - 100) + 50;
        const y = Math.random() * (canvas.height - 100) + 50;
        powerUps.push(new PowerUp(x, y, type));
    }
}

// Update particles
function updateParticles() {
    particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vy += 0.2; // Gravity
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
    });
}

// Draw particles
function drawParticles() {
    particles.forEach(p => {
        const alpha = p.life / p.maxLife;
        
        if (p.type === 'smoke') {
            ctx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.5})`;
        } else if (p.type === 'spark') {
            ctx.fillStyle = `rgba(255, 200, 0, ${alpha})`;
        } else if (p.type === 'explosion') {
            ctx.fillStyle = `rgba(255, ${100 * alpha}, 0, ${alpha})`;
        }
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Update UI
function updateUI() {
    document.getElementById('health1').style.width = player1.health + '%';
    document.getElementById('health2').style.width = player2.health + '%';
    document.getElementById('shield1').textContent = Math.ceil(player1.shield);
    document.getElementById('shield2').textContent = Math.ceil(player2.shield);
}

// Game loop
function update() {
    if (!gameOver) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw arena
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 5;
        ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
        
        // Update
        player1.update(keys, player2);
        player2.update(keys, player1);
        spawnPowerUp();
        updateParticles();
        
        // Update and draw power-ups
        powerUps = powerUps.filter(powerUp => {
            powerUp.update();
            powerUp.draw();
            
            if (powerUp.checkCollision(player1)) return false;
            if (powerUp.checkCollision(player2)) return false;
            return true;
        });
        
        // Draw particles
        drawParticles();
        
        // Draw cars
        player1.draw();
        player2.draw();
        
        // Update UI
        updateUI();
    } else {
        // Show game over
        const winner = player1.isDead ? "PLAYER 2" : "PLAYER 1";
        const color = player1.isDead ? "#0066ff" : "#ff0000";
        document.getElementById('winner').textContent = winner + " WINS!";
        document.getElementById('winner').style.color = color;
        document.getElementById('gameover').style.display = 'block';
    }
    
    requestAnimationFrame(update);
}

// Start game
update();
</script>
</body>
</html>