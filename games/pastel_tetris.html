<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<title>Pastelový Tetris – tmavší tóny</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(135deg, #2c2f3f, #3a3d55);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: "Segoe UI", sans-serif;
    overflow: hidden; /* Prevent scrolling */
  }
  
  /* Container to hold canvas and overlay relative to each other */
  #game-container {
    position: relative;
    border-radius: 20px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.35);
  }

  canvas {
    display: block;
    background: #2a2d3e;
    border-radius: 20px;
  }

  #score {
    position: absolute;
    top: -40px; /* Moved above the game container */
    left: 0;
    width: 100%;
    text-align: center;
    color: #d6d6e7;
    font-size: 24px;
    letter-spacing: 1px;
    font-weight: 600;
  }

  /* Game Over Overlay Styles */
  #game-over {
    display: none; /* Hidden by default */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(42, 45, 62, 0.92); /* Semi-transparent dark match */
    border-radius: 20px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: #fff;
    z-index: 10;
    backdrop-filter: blur(4px);
  }

  #game-over h2 {
    font-size: 32px;
    margin: 0 0 10px 0;
    color: #c7829e; /* Dusty pink */
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  #final-score-text {
    font-size: 16px;
    color: #aeb2c5;
    margin-bottom: 5px;
  }

  #final-score {
    font-size: 36px;
    font-weight: bold;
    color: #7fb096; /* Muted mint */
    margin-bottom: 30px;
  }

  button.restart-btn {
    background: #7f9ccf; /* Dusty blue */
    color: #1a1c29;
    border: none;
    padding: 12px 24px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 50px;
    cursor: pointer;
    transition: transform 0.2s, background 0.2s;
    box-shadow: 0 4px 15px rgba(127, 156, 207, 0.3);
  }

  button.restart-btn:hover {
    background: #a18bc9; /* Soft lavender */
    transform: scale(1.05);
  }

  button.restart-btn:active {
    transform: scale(0.95);
  }

</style>
</head>
<body>

<div id="game-container">
    <div id="score">Skóre: 0</div>
    
    <div id="game-over">
        <h2>Konec hry</h2>
        <div id="final-score-text">Dosažené skóre</div>
        <div id="final-score">0</div>
        <button class="restart-btn" onclick="resetGame()">Hrát znovu</button>
    </div>

    <canvas id="game" width="300" height="600"></canvas>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const gameOverScreen = document.getElementById("game-over");
const finalScoreDisplay = document.getElementById("final-score");

ctx.scale(30, 30);

// tmavší pastelová paleta (dusty pastel)
const colors = [
  null,
  "#c7829e", // dusty pink
  "#c9a66b", // muted peach
  "#c7c77a", // soft mustard
  "#7fb096", // muted mint
  "#7f9ccf", // dusty blue
  "#a18bc9", // soft lavender
  "#c27ba0"  // mauve
];

const arena = createMatrix(10, 20);
const player = { pos: {x: 0, y: 0}, matrix: null, score: 0 };
let isGameOver = false; // Flag to track game state
let requestID = null; // To handle animation loop

function createMatrix(w, h) {
  return Array.from({length: h}, () => Array(w).fill(0));
}

function createPiece(type) {
  if (type === "T") return [[0,1,0],[1,1,1]];
  if (type === "O") return [[2,2],[2,2]];
  if (type === "L") return [[0,0,3],[3,3,3]];
  if (type === "J") return [[4,0,0],[4,4,4]];
  if (type === "I") return [[5,5,5,5]];
  if (type === "S") return [[0,6,6],[6,6,0]];
  if (type === "Z") return [[7,7,0],[0,7,7]];
}

function drawMatrix(matrix, offset) {
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        ctx.fillStyle = colors[value];
        ctx.fillRect(x+offset.x, y+offset.y, 1, 1);
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.strokeRect(x+offset.x, y+offset.y, 1, 1);
      }
    });
  });
}

function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        arena[y+player.pos.y][x+player.pos.x] = value;
      }
    });
  });
}

function collide(arena, player){
  const [m,o]=[player.matrix,player.pos];
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 &&
        (arena[y+o.y] &&
         arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function rotate(matrix){
  return matrix[0].map((_,i)=>matrix.map(row=>row[i])).reverse();
}

function playerReset(){
  const pieces = "TJLOSZI";
  player.matrix = createPiece(pieces[Math.floor(Math.random()*pieces.length)]);
  player.pos.y = 0;
  player.pos.x = (arena[0].length / 2 | 0) -
                 (player.matrix[0].length / 2 | 0);

  // Check for collision immediately after spawning (Game Over condition)
  if(collide(arena, player)){
    isGameOver = true;
    finalScoreDisplay.innerText = player.score;
    gameOverScreen.style.display = "flex"; // Show Game Over screen
    cancelAnimationFrame(requestID); // Stop the loop
  }
}

// Function called by the "Hrát znovu" button
function resetGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    updateScore();
    isGameOver = false;
    gameOverScreen.style.display = "none";
    playerReset();
    update();
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    arenaSweep();
    playerReset();
  }
  dropCounter = 0;
}

function arenaSweep(){
  let rowCount = 1;
  outer: for(let y=arena.length-1; y>=0; y--){
    for(let x=0; x<arena[y].length; x++){
      if(arena[y][x]===0) continue outer;
    }
    arena.splice(y,1);
    arena.unshift(new Array(10).fill(0));
    player.score += rowCount * 10;
    rowCount *= 2;
    y++;
  }
  updateScore();
}

function updateScore(){
  document.getElementById("score").innerText = "Skóre: " + player.score;
}

let dropCounter = 0;
let dropInterval = 750;
let lastTime = 0;

function update(time=0){
  if (isGameOver) return; // Stop updating if game is over

  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestID = requestAnimationFrame(update);
}

function draw(){
  ctx.fillStyle = "#2a2d3e";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena,{x:0,y:0});
  drawMatrix(player.matrix,player.pos);
}

document.addEventListener("keydown", event=>{
  if (isGameOver) return; // Disable controls during Game Over

  if(event.key==="ArrowLeft"){
    player.pos.x--;
    if(collide(arena,player)) player.pos.x++;
  }
  if(event.key==="ArrowRight"){
    player.pos.x++;
    if(collide(arena,player)) player.pos.x--;
  }
  if(event.key==="ArrowDown") playerDrop();
  if(event.key==="ArrowUp"){
    const original = player.matrix;
    player.matrix = rotate(player.matrix);
    if(collide(arena,player)) player.matrix = original;
  }
  if(event.code==="Space"){
    while(!collide(arena,player)){
      player.pos.y++;
    }
    player.pos.y--;
    playerDrop();
  }
});

playerReset();
update();
</script>

</body>
</html>