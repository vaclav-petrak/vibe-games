<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Tyrian: JS Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 10px #00d2ff;
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        p { margin: 5px 0; font-size: 16px; opacity: 0.8; }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            text-shadow: 0 0 20px #ff0055;
        }
        #game-over h2 { font-size: 48px; margin: 0; }
        #game-over button {
            margin-top: 20px;
            padding: 10px 30px;
            background: transparent;
            border: 2px solid #00d2ff;
            color: #00d2ff;
            font-size: 18px;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 0 10px #00d2ff;
        }
        #game-over button:hover {
            background: #00d2ff;
            color: black;
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>NEON TYRIAN</h1>
    <p>Score: <span id="scoreVal">0</span></p>
    <p>Health: <span id="healthVal">100</span>%</p>
</div>

<div id="game-over">
    <h2>SYSTEM FAILURE</h2>
    <p>Final Score: <span id="finalScore">0</span></p>
    <button onclick="resetGame()">REBOOT SYSTEM</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ENGINE CONFIGURATION & SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width, height;
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input Handling
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// Game State
let gameRunning = true;
let score = 0;
let frame = 0;
let difficulty = 1;

// Entity Arrays
let player;
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];

/**
 * GRAPHICS & HELPERS
 */
function randomRange(min, max) { return Math.random() * (max - min) + min; }

function drawGlowingShape(ctx, x, y, color, blur, drawFn) {
    ctx.save();
    ctx.translate(x, y);
    ctx.shadowBlur = blur;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    ctx.strokeStyle = color; // For hollow shapes
    drawFn(ctx);
    ctx.restore();
}

/**
 * CLASSES
 */

// Background Starfield
class Star {
    constructor() {
        this.reset(true);
    }
    reset(randomY = false) {
        this.x = Math.random() * width;
        this.y = randomY ? Math.random() * height : -10;
        this.z = Math.random() * 2 + 0.5; // Depth/Speed
        this.size = Math.random() * 1.5;
        this.opacity = Math.random() * 0.5 + 0.3;
    }
    update() {
        this.y += this.z * 2; // Parallax speed
        if (this.y > height) this.reset();
    }
    draw() {
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// Particle System (Explosions/Trails)
class Particle {
    constructor(x, y, color, speed, size, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = Math.random() * speed;
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = life;
        this.maxLife = life;
        this.size = size;
        this.decay = Math.random() * 0.05 + 0.02;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.95; // Shrink
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// Player Ship
class Player {
    constructor() {
        this.x = width / 2;
        this.y = height - 100;
        this.width = 30;
        this.height = 40;
        this.speed = 7;
        this.hp = 100;
        this.lastShot = 0;
        this.fireRate = 8; // Frames between shots
        this.tilt = 0; // Visual banking
    }

    update() {
        // Movement
        if (keys['ArrowLeft'] || keys['KeyA']) {
            this.x -= this.speed;
            this.tilt = -0.3;
        } else if (keys['ArrowRight'] || keys['KeyD']) {
            this.x += this.speed;
            this.tilt = 0.3;
        } else {
            this.tilt = 0;
        }

        if (keys['ArrowUp'] || keys['KeyW']) this.y -= this.speed;
        if (keys['ArrowDown'] || keys['KeyS']) this.y += this.speed;

        // Boundaries
        this.x = Math.max(20, Math.min(width - 20, this.x));
        this.y = Math.max(20, Math.min(height - 20, this.y));

        // Shooting
        if (keys['Space']) {
            if (frame - this.lastShot > this.fireRate) {
                bullets.push(new Bullet(this.x - 10, this.y, -12, '#00ffff')); // Left gun
                bullets.push(new Bullet(this.x + 10, this.y, -12, '#00ffff')); // Right gun
                this.lastShot = frame;
            }
        }

        // Engine Trail
        particles.push(new Particle(this.x + randomRange(-5,5), this.y + 20, '#00d2ff', 2, 3, 0.5));
    }

    draw() {
        drawGlowingShape(ctx, this.x, this.y, '#00d2ff', 20, (c) => {
            c.rotate(this.tilt);
            // Ship Body
            c.beginPath();
            c.moveTo(0, -20);
            c.lineTo(15, 15);
            c.lineTo(0, 10);
            c.lineTo(-15, 15);
            c.closePath();
            c.fill();
            
            // Cockpit
            c.fillStyle = "white";
            c.beginPath();
            c.moveTo(0, -5);
            c.lineTo(3, 5);
            c.lineTo(-3, 5);
            c.fill();
        });
    }
}

// Projectiles
class Bullet {
    constructor(x, y, vy, color, isEnemy = false) {
        this.x = x;
        this.y = y;
        this.vy = vy;
        this.color = color;
        this.isEnemy = isEnemy;
        this.width = 4;
        this.height = 15;
        this.markedForDeletion = false;
    }
    update() {
        this.y += this.vy;
        if (this.y < 0 || this.y > height) this.markedForDeletion = true;
    }
    draw() {
        drawGlowingShape(ctx, this.x, this.y, this.color, 10, (c) => {
            c.fillStyle = "white"; // Core
            c.fillRect(-2, -7, 4, 14);
        });
    }
}

// Enemies
class Enemy {
    constructor(type) {
        this.type = type; // 0: Basic, 1: Interceptor, 2: Heavy
        this.x = Math.random() * (width - 60) + 30;
        this.y = -50;
        this.hp = type === 2 ? 10 : (type === 1 ? 3 : 1);
        this.color = type === 2 ? '#ff0055' : (type === 1 ? '#ffcc00' : '#aa00ff');
        this.speed = type === 1 ? 5 : 2;
        this.markedForDeletion = false;
        this.timeOffset = Math.random() * 100;
    }

    update() {
        this.y += this.speed;

        // Sine wave movement for Interceptors
        if (this.type === 1) {
            this.x += Math.sin((frame + this.timeOffset) * 0.05) * 3;
        }

        // Shooting logic
        if (Math.random() < 0.01 + (difficulty * 0.001)) {
            let projectileSpeed = this.type === 2 ? 5 : 7;
            bullets.push(new Bullet(this.x, this.y + 20, projectileSpeed, '#ffaa00', true));
        }

        if (this.y > height + 50) this.markedForDeletion = true;
    }

    draw() {
        drawGlowingShape(ctx, this.x, this.y, this.color, 15, (c) => {
            if (this.type === 0) { // Basic Drone (Diamond)
                c.beginPath();
                c.moveTo(0, -15);
                c.lineTo(15, 0);
                c.lineTo(0, 15);
                c.lineTo(-15, 0);
                c.closePath();
                c.fill();
            } else if (this.type === 1) { // Interceptor (Arrow)
                c.beginPath();
                c.moveTo(0, 15);
                c.lineTo(12, -15);
                c.lineTo(0, -5);
                c.lineTo(-12, -15);
                c.closePath();
                c.fill();
            } else { // Heavy (Boxy)
                c.fillRect(-20, -20, 40, 40);
            }
        });
    }
}

/**
 * GAME LOGIC
 */

function init() {
    player = new Player();
    bullets = [];
    enemies = [];
    particles = [];
    score = 0;
    gameRunning = true;
    difficulty = 1;
    
    // Create Stars
    stars = [];
    for(let i=0; i<100; i++) stars.push(new Star());

    document.getElementById('game-over').style.display = 'none';
    document.getElementById('scoreVal').innerText = "0";
    document.getElementById('healthVal').innerText = "100";
    
    loop();
}

function spawnEnemies() {
    if (frame % 60 === 0) {
        // Basic spawn
        enemies.push(new Enemy(0));
    }
    if (frame % 150 === 0 && score > 100) {
        // Interceptor spawn
        enemies.push(new Enemy(1));
    }
    if (frame % 300 === 0 && score > 500) {
        // Heavy spawn
        enemies.push(new Enemy(2));
    }
}

function checkCollisions() {
    // Bullets hit Enemies
    bullets.forEach(bullet => {
        if (bullet.isEnemy) return;
        enemies.forEach(enemy => {
            const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
            if (dist < 30) { // Hit
                bullet.markedForDeletion = true;
                enemy.hp--;
                
                // Hit effect
                for(let i=0; i<3; i++) particles.push(new Particle(bullet.x, bullet.y, 'white', 5, 2, 0.5));

                if (enemy.hp <= 0) {
                    enemy.markedForDeletion = true;
                    score += (enemy.type + 1) * 100;
                    document.getElementById('scoreVal').innerText = score;
                    
                    // Explosion
                    for(let i=0; i<15; i++) {
                        particles.push(new Particle(enemy.x, enemy.y, enemy.color, 8, 4, 1.0));
                    }
                }
            }
        });
    });

    // Enemy Bullets/Bodies hit Player
    enemies.forEach(enemy => {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < 30) {
            enemy.markedForDeletion = true;
            damagePlayer(20);
             // Crash Explosion
             for(let i=0; i<15; i++) particles.push(new Particle(enemy.x, enemy.y, 'orange', 8, 4, 1.0));
        }
    });

    bullets.forEach(bullet => {
        if (!bullet.isEnemy) return;
        const dist = Math.hypot(bullet.x - player.x, bullet.y - player.y);
        if (dist < 20) {
            bullet.markedForDeletion = true;
            damagePlayer(10);
            for(let i=0; i<5; i++) particles.push(new Particle(player.x, player.y, 'red', 5, 2, 0.5));
        }
    });
}

function damagePlayer(amount) {
    player.hp -= amount;
    document.getElementById('healthVal').innerText = Math.max(0, player.hp);
    
    // Screen shake simulation (offsetting canvas briefly would be better, but flashes work well)
    document.body.style.backgroundColor = '#330000';
    setTimeout(() => document.body.style.backgroundColor = '#050505', 50);

    if (player.hp <= 0) {
        gameOver();
    }
}

function gameOver() {
    gameRunning = false;
    document.getElementById('finalScore').innerText = score;
    document.getElementById('game-over').style.display = 'block';
}

function resetGame() {
    init();
}

function loop() {
    if (!gameRunning) return;

    // Clear Screen
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    // Update & Draw Stars
    stars.forEach(star => { star.update(); star.draw(); });

    // Update Player
    player.update();
    player.draw();

    // Spawning
    spawnEnemies();

    // Update Entities
    bullets = bullets.filter(b => !b.markedForDeletion);
    enemies = enemies.filter(e => !e.markedForDeletion);
    particles = particles.filter(p => p.life > 0);

    bullets.forEach(b => { b.update(); b.draw(); });
    enemies.forEach(e => { e.update(); e.draw(); });
    particles.forEach(p => { p.update(); p.draw(); });

    checkCollisions();

    // Difficulty scaling
    difficulty = 1 + (score / 1000);

    frame++;
    requestAnimationFrame(loop);
}

// Start
init();

</script>
</body>
</html>